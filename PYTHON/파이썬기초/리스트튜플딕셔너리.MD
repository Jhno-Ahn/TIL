- 리스트
    - 모든 객체의 시퀀스
    - 리스트 메소드
    - []
- 튜플
    - 패킹과 언패킹
    - 튜플 메소드
    - ()
- 딕셔너리
    - 키와 값으로 구성
    - {}

## 리스트

- 리스트는 **데이터의 목록을 다루는 자료형**
- 단일 데이터가 명함이라면, 리스트는 명함을 모아두는 명함집
- 슬롯(Slot) : 리스트의 데이터를 삽입할 자리
- 요소(Element) : 리스트의 각 슬롯에 꽂혀있는 개별 데이터
- 배열(Array)과 비슷한 개녕
- **차이점 : 서로 다른 데이터형도 요소가 될 수 있다는 점**

```python

#문자열
a = ['박지성', '손흥민', '차범근']
a[0]
'박지성'
a[1]
'손흥민'
a[2]
'차범근'

#슬라이싱
a = [1,2,3,4,5,6,7,8,9,10]
a[0:5]
[1, 2, 3, 4, 5]
a[5:]
[6, 7, 8, 9, 10]
a[:3]
[1, 2, 3]

#리스트간의 결합
a = [1,2,3,4,]
b = [5,6,7,]
a+b
[1, 2, 3, 4, 5, 6, 7]

#append
#항목 자체가 하나의 인자로 추가
a = [1,2,3]
a.append([4,5,6])
a
[1,2,3,[4,5,6]]

#extend()
#기존 리스트에 다른 리스트를 이어 붙임 (+연산자, 다른 리스트를 병합)
a = [1,2,3]
a.extend()
a
[1,2,3,4,5,6]

#insert()
#첨자로 명시한 리스트 내의 위치에 새 요소 삽입
a = [2,4,5]
a.insert(0,1) # 0번째위치에 데이터 1을 삽입)
a
[1,2,4,5]

#remove()
#매개 변수로 입력한 데이터를 리스트에서 찾아 발견한 첫 번째 요소를 제거합니다.
a=['a','b','c','d']
a.remove('a')        
a        
['b', 'c', 'd']

#pop()
#리스트의 마지막 요소를 뽑아내어 리스트에서 제거합니다.
a = [1,2,3,4,5]
a.pop()
5
a
[1, 2, 3, 4]
a.pop()
4
a
[1, 2, 3]

#특정 요소를 제거하고 싶을 때에는 제거하고자 하는 인덱스를 입력하면 된다.
a.pop(2)
3
a
[1, 2]

#index()
#매개변수로 입력한 데이터와 일치하는 요소의 첨자를 알려준다.
a = ['a','b','c']
a.index('a')
0
a.index('b')
1

#count()
#매개변수로 입력한 데이터와 일치하는 요소가 몇 개 존재하는지 센다.
a = [1,100,2,100,3,100]
a.count(100)
3
a.count(1)
1

#sort()
#리스트 내의 요소를 정렬. 매개변수로 reverse = True를 입력하면 내림차순, 
#아무것도 입력하지 않으면 오름차순으로 정렬
a = [3,4,5,2,1]
a.sort()
a
[1, 2, 3, 4, 5]
a.sort(reverse = True)
a
[5, 4, 3, 2, 1]

#reverse()
#리스트 내 요소의 순서를 반대로 뒤집는다.
a = ['요', '세', '하', '녕', '안']
a.reverse()
a
['안', '녕', '하', '세', '요']
```

## 튜플

- 리스트는 “목록”, 튜플은 “N개의 요소로 된 집합”
- 리스트는 데잍 변경 가능, 튜플은 데이터 변경 불가능
- 튜플은 위경도 좌표나 RGB 색상처럼 작은 규모의 자료구조를 구성하기에 적합
- 성능
    - 데이터를 할당할 공간의 내용이나 크기가 달라지지 않기 때문에 생성 과정이 간단
    - 데이터가 오염되지 않을 것이라는 보장이 있기 때문에 원본 사용
- 신뢰 가능한 코드
    - 변경되지 않아야 할 데이터를 오염시키는 버그를 만들 가능성 제거
    - 코드를 설계할 때부터 변경이 가능한 데이터와 그렇지 않은 데이터를 정리해서 코드에 반영

```python
#변경 불가능 테스트
a = (1,2,3)
a[0]
1
a[0] = 7 #튜플은 리스트와 다르게 데이터 변경 불가능!!
Traceback (most recent call last):
  File "<pyshell#35>", line 1, in <module>
    a[0] = 7
TypeError: 'tuple' object does not support item assignment

#튜플패킹
a = 1,2,3 #패킹 : 여러 데이터를 튜플로 묶는 것
a
(1, 2, 3)

#튜플 언패킹
one, two, three = a #언패킹 : 튜플의 각 요소를 여러 개의 변수에 할당
one
1
two
2
three
3

#언패킹을 이용한 변수 다중 할당
MU, TOT, NUM = 'PARK', 'SON' , 7
MU
'PARK'
TOT
'SON'
NUM
7

#언패킹을 이용한 변수 다중 할당
p = 'abc'
q = 'defg'
p, q = q, p #치환문 오른쪽이 튜플로 패킹 된 후에, 치환문 왼쪽의 변수에 언패킹 되어 할당.
p
'defg'
q
'abc'

#확장 언패킹
a = (1,2,3,4,5)
b, *c, d = a
print(a)
(1, 2, 3, 4, 5)
print(b,c,d)
1 [2, 3, 4] 5   #확장 언패킹(*)은 리스트
```

## 딕셔너리

- 리스트처럼 첨자를 이용해서 요소에 접근
- 리스트는 0부터 시작하는 수 첨자만 사용할 수 있지만 딕셔너리는 문자열과 숫자를 비록해서 변경이 불가능한 형식이면 어떤 자료형이든 키로 사용 가능
    - 딕셔너리의 첨자는 키 - 반드시 유일
    - 이 키가 가르키는 슬롯에 저장되는 데이터를 일컬어 값(Value)
    - 딕셔너리는 키-값의 쌍으로 구성
- 탐색속도가 빠르고, 편리
- {} 이용
- 새로운 키-값을 입력하거나 딕셔너리 안에 있는 요소를 참조할 때는 []를 이용

```python
#딕셔너리 생성
dic = {}
dic['파이썬'] = 'Python'
dic['애플'] = 'Apple'

dic['파이썬']    
'Python'

dic['애플']    
'Apple'

dic    
{'파이썬': 'Python', '애플': 'Apple'}

#key, values
dic.keys()
dict_keys(['파이썬', '애플'])

dic.values()    
dict_values(['Python', 'Apple'])

#items
dic.items()
dict_items([('파이썬', 'Python'), ('애플', 'Apple')])

#in 연산자
'애플' in dic.keys()    
True

'잡스' in dic.keys()    
False

'Python' in dic.values()    
True

'Java' in dic.values()    
False

#pop(), clear()
dic.pop('애플') #키가 애플인 요소를 삭제
'Apple'
dic    
{'파이썬': 'Python'}

dic.clear()   #싹 지움
dic    
{}
```

## 셋

- 값은 버리고 키만 남은 딕셔너리 (존재 여부 판단에 사용)

## 중요 사항

```python
#복합 객체 자료형(복합 시퀀스 객체의 트리)
#내장된 자료형을 결합해서 더 크고 복잡한 자료구조 생성
L = ['abc',[(1,2),([3],4)],5]    
L[1]    
[(1, 2), ([3], 4)]

L[1][1]    
([3], 4)

L[1][1][0]    
[3]

L[1][1][0][0]    
3

#할당 : =
a = [1,2,3]
b = a #얕은 복사
a[0] = 'surprise'   
a    
['surprise', 2, 3]

b    
['surprise', 2, 3]
```
