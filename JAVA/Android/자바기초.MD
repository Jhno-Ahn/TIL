# 안드로이드 앱 개발을 위한 필요한 기초적인 자바 문법

1. 자료형
2. Casting
3. final, static
4. if(), switch()
5. for(), while(), do-while()
6. Array
7. Method
8. Overload, Overriding
9. Class
10. Object
11. Polymorphism
12. 접근 지정자
13. Constructor
14. Inheritance
15. super()
16. Abstract Class
17. Interface
18. Exception
19. Tread
20. Lamda
21. Generic
22. Collection Framework

## 1. 자료형

- 어떤 형태의 변수를 넣을지 정하는 것

<img width="705" alt="스크린샷 2022-05-27 오후 6 04 14" src="https://user-images.githubusercontent.com/81155572/170668214-e6732998-321f-48b3-a689-0697831b16b3.png">


## 2. Casting(타입변환)

### Casting 이란?

- 자바에서 캐스팅은 타입을 변환하는 것이다.
- 상속 관계에 있는 부모와 자식 클래스 간에는 서로 형변환이 가능하다.
- 업 캐스팅
    - 자식 클래스가 부모 클래스 타입으로 캐스팅 되는 것.
- 다운 캐스팅
    - 부모 클래스가 자식 클래스 타입으로 캐스팅 되는 것.


## 3. final, static

### final

- final 변수
    - 변수를 상수화 시킨다. 변경은 불가능
- final 클래스
    - 상속을 허용하지 않는다. 대표적으로 String 클래스가 있다.
- final 메소드
    - 오버라이딩을 허용하지 않는다. 클래스는 상속이 가능하되, 해당 메소드는 오버라이딩이 불가능하다.

### static

- static 변수란?
    - static으로 선언된 변수는 메모리 공간에 하나만 존재하며, 어디서나 접근이 가능한 변수.(public 선언시)
    - 클래스 내부에서는 얼마든지 직접 접근이 가능하다.
    - 클래스 외부에서 인스턴스의 이름이나 클래스의 이름을 통해 접근하는 것도 가능
- static 변수의 초기화 시점
    - static 변수는 인스턴스가 생성되기 이전에 별도의 메모리 공간에 할당되어 초기화까지 완료된다.
    - **초기화되는 시점은 JVM에 의해서 클래스가 메모리 공간에 올라가는 순간이다.**
- static 변수 사용 이유
    - 인스턴스간에 데이터 공유가 필요한 상황에서 static 변수를 선언한다.
- static final 선언
    - 클래스 내부 또는 외부에서 참조의 용도로만 선언된 변수는 static final로 선언한다.
- static 메소드란?
    - 인스턴스를 생성하지 않아도 static 메소드를 호출할 수 있다.
    - 사용 이유는 객체를 생성할 필요가 없는 메소드에 붙인다. 인스턴스 변수에 접근하지 않는다면 static 메소드로 정의해야 한다.
- public static void main
    - main 메소드는 인스턴스의 생성과 관계없이 JVM에 의해 호출이 되므로 반드시 static으로 선언해야 한다.

## 4. if , switch

### 조건문

- 조건식문은 if와 switch로 나뉨
- 처리할 경우의 수가 많을 때는 switch문이 효율적이지만, if문보다 제약이 많음

### if

- 가장 기본적인 조건문
- 조건식의 결과는 true or false여야 함
- 블럭 안에는 보통 여러 문장을 넣지만, 한 문장만 넣거만 아무런 문장도 넣지 않을 수 있음.
- 한 문장만 넣을 때는 괄호를 생략할 수 있지만 가능하면 생략하지 않는 것이 바람직함

### switch

- 처리할 경우의 수가 많은 경우에는 if문보다는 switch문으로 작성하는 것이 좋음
    - if문은 조건식의 결과가 참과 거짓 밖에 없기 때문에 경우의 수가 많아질수록 복잡해지고 처리 시간 길어짐
    - 반면에 switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고, 표현이 간결
- 제약조건이 있다.
    - switch문의 조건식 결과는 정수 또는 문자열이어야 한다.
    - case문의 값은 정수 상수 및 문자열 상수만 가능하며 중복되지 않아야 한다.
- switch문
    - 조건식을 먼저 계산
    - 결과와 일치하는 case문으로 이동
    - 이후의 문장들을 수행
    - break문이나 switch문의 끝을 만나면 switch문 전체를 빠져나감

## 5.  for, while, do-while

### for

```java
for(초기화식; 조건식; 증감식){
	실행문;
}
```

- 초기화식 : 반복 횟수를 제어하는 변수 초기화식이 제일 먼저 실행된다.
- 조건식 : 조건식을 검사해서 true이면 실행문을 실행, false면 for문을 종료
- 증감식 : 실행문이 모두 실행되면 증감식을 실행한 후 다시 조건식을 검사한다. 반복.

### while

```java
while(조건식){
	실행문 //반복영역
}
```

- 조건식이 true이면 실행문을 실행한 후 다시 조건문을 검사
- 조건식이 false이면, while문 종료

### do - while

```java
do { 
	실행문
} while(조건식);
```

- while()뒤에는 반드시 세미콜론 붙어야함
- 실행문이 우선 수행된 후
- 조건식을 검사, true이면 실행문을 반복 수행하고 , false이면 do-while문을 종료한다.


## 6. Array

### Array(배열)의 정의

- 같은 데이터 타입을 가지는 서로 다른 값들이 하나의 변수로 처리되는 자료 구조이다.
- 자료형의 집합을 의미.
- 배열은 Resizing이 안된다.

### 생성

<aside>
💡 자료형[] 배열이름 = new 자료형[길이];

</aside>

<aside>
💡 자료형[] 배열이름 ={요소1, 요소2, 요소3…}

</aside>

- 배열의 길이는 값을 저장할 수 있는 공간의 개수다.

### 메모리

- Stack(스택) : 아직 값을 모르는 배열 변수가 들어간다.
- Heap(힙) : 배열 개수만큼 default 값으로 들어간다. 주소값이 지정된다.
- 할당된 주소값은 Stack에 있는 배열 변수에 들어간다.
- Heap에 있는 값들을 배열 변수로 가져올 수 있다.
- 배열 변수는 순서가 있다.
- 마지막 요소 : 마지막 수 -1

### 이차원 배열

```jsx
자료형[][] 배열이름 = new 자료형[행개수][열개수];
int[][] arr = new int[3][4];
int[][] arr = { {1,2,3},{4,5,6,7} };
```

## 7. Method(메소드)

### 메소드를 사용하는 이유

- 반복해서 사용하는 경우가 있다.
- 이러한 것들을 한 뭉치로 묶어서 “어떤 입력값을 주었을 때 리턴값을 돌려준다”
- 이런식으로 사용하면 훨씬 편해진다.

```jsx
int sum(int a, int b) {
		return a+b;
}
// "sum 메소드는 입력값으로 두개의 값(int 자료형 a, int 자료형 b)을 받으며
// 리턴값은 두 개의 입력값을 더한 값(int 자료형)이다."
```

### 메소드의 구조

```jsx
리턴자료형 메소드명(입력자료형1 매개변수, 입력자료형2 매개변수2...){
	...
	return 리턴값; //리턴자료형이 void인 경우에는 return문이 필요없다.
}
```

- 리턴자료형은 메소드 수행 후 돌려줄 값의 자료형을 의미한다.
- 메소드는 입출력 유무에 따라 다음과 같이 4가지로 분류
    - 입력과 출력이 모두 있는 메소드
    - 입력과 출력이 모두 없는 메소드
    - 입력은 없고 출력은 있는 메소드
    - 입력은 있고 출력은 없는 메소드

### 일반적인 메소드

- 입력 값이 있고 리턴값이 있는 메소드가 일반적인 메소드이다.

```jsx
int sum(int a, int b){
	return a+b;
}
---------------------------
Sample sp = new Sample();
int result = sp.sum(3,4);
```

- 입력값 - int 자료형 a , int 자료형 b
- 리턴 값 - int 자료형

### 입력값이 없는 메소드

```jsx
String say(){
	return "HI";
}
------------------------
Sample sp = new Sample();
String a = sp.say();
Sysout(a); //"HI" 출력

```

- 입력 값 - 없음
- 리턴 값 - String 자료형

### 리턴값이 없는 메소드

```jsx
void sum(int a, int b){
	Sysout(a + "와" + b +"의 합은 "+ (a+b) +"이다");
}

-------------------------------------------
Sample sp = new Sample();
sp.sum(3,4) // "3와 4의 합은 7입니다" 출력
```

- 입력 값 - int 자료형 a, int 자료형 b
- 리턴 값 - void(없음)

### 입력값도 리턴값도 없는 메소드

```jsx
void say() {
	Sysout("Hi");
}

-----------------------------

Sample sp = new Sample();
sp.say(); // HI 출력
```

- 입력 값 - 없음
- 리턴 값 - 없음
